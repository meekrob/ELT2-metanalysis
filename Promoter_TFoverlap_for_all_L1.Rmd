---
title: "Intestine promoter binding"
author: "David C. King and Ambika"
date: "11/11/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(dplyr)
library(GenomicRanges)
library(pheatmap)
library(fpc) 
# distance.cosine = function(u,v) {
#   1 - ((u%*%v) / (norm(u,"2")*norm(v,"2")))
# }
cosine_dist = function(df) { # much faster
  M = as.matrix(df)
  sim = M / sqrt(rowSums(M*M))
  sim = sim %*% t(sim)
  as.dist(1-sim)
}
```

See https://stats.stackexchange.com/questions/31565/compute-a-cosine-dissimilarity-matrix-in-r/367216#367216 for the efficient computation of the cosine dissimilarity.

## Goal

This analysis is looking for TFs that may explain intestine expression in the absence of ELT-2.

## Promoters

Genes which fall under different classes of intestine enrichment in Williams et al. 2023
are assigned promoters gene 5' -1Kb/200bp. 

The dataset has each promoter in the genome annotated with intestine expression DESeq information, as well as ELT-2 binding status gotten from Kudron et al. 2018.

```{r promoters}
promoters_df = readRDS('DATA/promoter_data.rds')
promoters_df %>% head()

```

### Promoters by intestine enrichment status



```{r enrichment_depletion}
LE.enriched = promoters_df %>% filter(embryo_int_exp != "depleted")
L1.enriched = promoters_df %>% filter(L1_int_exp != "depleted")
L3.enriched = promoters_df %>% filter(L3_int_exp != "depleted")
promoters_gr = makeGRangesFromDataFrame(L1.enriched, keep.extra.columns = T, seqinfo=Seqinfo(genome="ce11"))

```

```{r other-TFs}
TF.files = list.files('summit/modENCODEtracks/data/orig/L1',
                      full.names =TRUE,
                      pattern='*.bed')
factornames = lapply(str_split(TF.files, "[/.]"), function(x) x[[6]]) %>% unlist()
names(TF.files) = factornames

all.grs= lapply(TF.files, 
  function(fname) {
    factorname = str_split(fname, "[/.]")[[1]][6]
    data=read.table(fname)
    gr = makeGRangesFromDataFrame(data, keep.extra.columns = T, 
                                  seqnames.field = "V1",
                                  start.field = "V2",
                                  end.field = "V3", seqinfo=Seqinfo(genome="ce11"))
    return(gr)
  })
```

```{r}


for(TFname in names(all.grs))
{
  
  olap=countOverlaps(promoters_gr,all.grs[[TFname]])
  
  df = mcols(promoters_gr)# pull dataframe from GRanges metadata
  df[[TFname]] = olap
  
   mcols(promoters_gr) <- df # reassign dataframe to GRanges
   
}
```

```{r}

data = as.data.frame(mcols(promoters_gr))
data =data[,19:ncol(data)]
moddata= data[rowSums(data)!=0,]
colSums(as.data.frame(data))
```

```{r}
 
mtx_x <- matrix(unlist(moddata), ncol = length(moddata), byrow = TRUE)
heatmap(mtx_x,scale="none")
 
```

```{r}
mx = as.matrix(data)
mx.filt = mx[rowSums(mx) >0, ]
table(rowSums(mx.filt))
cat("fraction of zero values: ")
sum(mx.filt==0)/length(mx.filt)
```
# No filtering

```{r presence-absence-of-binding}

mx.ind = ifelse(mx.filt > 0, 1, 0)  
rs = rowSums(mx.ind)


# have to remove any full 0 rows/columns for clustering with cos
mx.ind = mx.ind[rs > 2,]
cs = colSums(mx.ind)
mx.ind = mx.ind[,cs > 0]
stopifnot(sum(rowSums(mx.ind) == 0)==0)
stopifnot(sum(colSums(mx.ind) == 0)==0)
```

```{r apply-cos-dist}
system.time({ # use cosine_dist instead of distance.cosine. See link referenced.
dist_cos_rows = cosine_dist(mx.ind)
dist_cos_cols = cosine_dist(t(mx.ind))
})
```

```{r hclust-for-screeplot}
hc.cos = hclust(dist_cos_rows, method="average")
plot(1:length(hc.cos$height),rev(hc.cos$height),  xlim=c(0,50), main="scree for cos.")
clusterboot(dist_cos_rows, B=100, bootmethod="boot",clustermethod=disthclustCBI, method="average", k=2)
hc.cos.k = cutree(hc.cos, 10)
hc.cos = hclust(dist_cos_cols, method="average")
plot(1:length(hc.cos$height),rev(hc.cos$height),  xlim=c(0,100), main="scree for cos. on cols")
```

```{r pheatmap}

pheatmap(mx.ind, clustering_distance_rows = dist_cos_rows,
         clustering_distance_cols = dist_cos_cols,
          cutree_rows = 10,
         # cutree_cols = 23,
         clustering_method = "average",
         color = c('#FFFFCC', '#68001C'), # to match heatmap() colors with 0/1
         main="TF presence/absence (no filtering of HOT regions)", 
         legend=FALSE
         #,file="hc.L1.HOT.pdf"
         )
```
## Filtered

```{r filtered}
mx.ind = ifelse(mx.filt > 0, 1, 0)  
rs = rowSums(mx.ind)
mx.ind = mx.ind[rs > 2 & rs < 20,]
cs = colSums(mx.ind)
mx.ind = mx.ind[,cs > 0]
stopifnot(sum(rowSums(mx.ind) == 0)==0)
stopifnot(sum(colSums(mx.ind) == 0)==0)
```

```{r apply-cos-dist-filtered}
system.time({
  dist_cos_rows = cosine_dist(mx.ind, method=distance.cosine)
  dist_cos_cols = cosine_dist(t(mx.ind), method=distance.cosine)})
```

```{r hclust-for-screeplot-filtered}
hc.cos = hclust(dist_cos_rows, method="average")
plot(1:length(hc.cos$height),rev(hc.cos$height),  xlim=c(0,100), main="scree for cos. on rows")
hc.cos = hclust(dist_cos_cols, method="average")
plot(1:length(hc.cos$height),rev(hc.cos$height),  xlim=c(0,100), main="scree for cos. on cols")
```
```{r pheatmap-filtered}
pheatmap(mx.ind, clustering_distance_rows = dist_cos_rows,
         clustering_distance_cols = dist_cos_cols,
         cutree_rows = 10, 

         clustering_method = "average",
         color = c('#FFFFCC', '#68001C'), # to match heatmap() colors with 0/1
         main="TF presence/absence ", 
         legend=FALSE
         #, file="hc.L1.noHOT.pdf" # uncomment to write to a file instead of plot
         )
```
