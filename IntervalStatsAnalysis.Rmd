---
title: "IntervalStats analysis"
author: "David C. King / Wynn Webster"
date: "2022-10-04"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(magrittr)
# clustering
#install.packages("amap")
library(amap)
#install.packages("smacof")
library(smacof)
library(cluster) # for agnes (hierarchical clustering)
#install.packages('fpc')
library(fpc) # for clusterboot
# visualization
library(pheatmap)
library(dendextend)
library(ggplot2)
library(ggrepel)
library(ggpubr) ## ggqqplot
library(dendsort)
```

## cosine dist function
https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.cosine.html

Use this link for the computation: https://stats.stackexchange.com/questions/31565/compute-a-cosine-dissimilarity-matrix-in-r/367216#367216

```{r cos-dist}
distance.cosine = function(u,v) {
  1 - ((u%*%v) / (norm(u,"2")*norm(v,"2")))
}

# https://stats.stackexchange.com/questions/31565/compute-a-cosine-dissimilarity-matrix-in-r/367216#367216
df_to_cosine_dist = function(df) {
  M = as.matrix(df)
  sim = sqrt(rowSums(M*M))
  sim = sim %*% t(sim)
  as.dist(1-sim)
}

```




## Get data

```{r genelists}
neuro.genelist = c('unc-42_LE',
          'ces-1_LE',
          'ceh-9_L3',
          'fkh-10_L4',
          'fkh-10_L1',
          'fkh-10_L3',
          'ces-1_L4',
          'ces-1_L1')
synMuvB.genelist = read.table('synMuvB.list')[[1]]
intestine.genelist = read.table('intestine.genelist')[[1]]
muscle.genelist = read.table('muscle.list')[[1]]
germline.genelist = read.table('germline.genelist')[[1]]
```

```{r alldata}
alldata = read.table('DATA/alldata')
colnames(alldata) <- c("factor1", "factor2", "sig1", "sig2", "sig_ave")

alldata = alldata %>% group_by(factor1, factor2) %>% summarise(sig_min = min(sig1,sig2), sig_max=max(sig1,sig2), sig_ave = max(sig_ave)) 


allfactors = unique(c(alldata[[1]], alldata[[2]]))
```

```{r reduce-inspect-clusters}
message("SynMuvB: ", sum(synMuvB.genelist %in% allfactors), " genes out of ", length(synMuvB.genelist), " in IntervalStats data.")
message("Intestine: ", sum(intestine.genelist %in% allfactors), " genes out of ", length(intestine.genelist), " in IntervalStats data.")
message("Muscle: ", sum(muscle.genelist %in% allfactors), " genes out of ", length(muscle.genelist), " in IntervalStats data.")
message("Neuro: ", sum(neuro.genelist %in% allfactors), " genes out of ", length(neuro.genelist), " in IntervalStats data.")
message("Germline: ", sum(germline.genelist %in% allfactors), " genes out of ", length(germline.genelist), " in IntervalStats data.")
```

```{r reduce-kudron-clusters}
synMuvB.genelist = synMuvB.genelist[synMuvB.genelist %in% allfactors]
intestine.genelist = intestine.genelist[intestine.genelist %in% allfactors]
muscle.genelist = muscle.genelist[muscle.genelist %in% allfactors]
germline.genelist = germline.genelist[germline.genelist %in% allfactors]
neuro.genelist = neuro.genelist[neuro.genelist %in% allfactors]
```


```{r filter-data}

```

```{r rectangularize-matrix}
matrix_tibble = pivot_wider(alldata, 
                            values_from = 'sig_ave', 
                            id_cols = c('factor1'), 
                            names_from = 'factor2')
head(matrix_tibble[,1:10])

# remove "factor1" column
mx = as.matrix(matrix_tibble[2:424])


dim(mx)
mx[1:10,1:10]
# this is essentially a half-matrix with one less row and column
# the following lines fill out the matrx
mx2 = cbind(matrix(NA,ncol=1, nrow=423),mx)
mx3 = rbind(mx2, matrix(NA,nrow=1, ncol=424))

# re-add the omitted row/col name
colnames(mx3) <- allfactors
rownames(mx3) <- allfactors

# full matrix
mx3[lower.tri(mx3)] <- mx3[upper.tri(mx3)]
rownames(mx3) <- colnames(mx3)
mx3[1:10,1:10]
```

```{r filtering-pre-log}
na_counts = apply(mx3, 1, function(x) { sum(is.na(x))})
table(na_counts)
```


- need: a matrix that has evenly distributed values: hclust(log(mx3))

- need: values must be distances: 0 is complete similarity, dissimilarity increasing > 0

- need: must be a "dist" object for hclust

- suggestion: try the smacof, sim2diss function (similarity to distance): sim2diss(s, method = "corr", to.dist = FALSE)

```{r translate-to-scoring-matrix}


log.scores = log(mx3+1)
max_score = max(log.scores, na.rm=T)
log.scores[diag(log.scores)] <- ceiling(max_score) # set the self comparisons to a higher (but close) number than what is observed

log.scores[is.na(log.scores)] <- 0 # take care of the rest of the NAs (they are comparisons that weren't present ini thee input data fle)



```

```{r sim2diss-methods}
allvals = data.frame()

#dist_scalar = sim2diss(log.scores, method = 8, to.dist = TRUE)

# methods that do a log transformation (use the original data)
dist_scalar = sim2diss(mx3, method = "Gaussian")
values = dist_scalar[upper.tri(dist_scalar, diag = T)]
range(values, na.rm = T)
allvals = rbind(allvals, data.frame(x=values, method="Gaussian"))

dist_scalar = sim2diss(mx3, method = "exp")
values = dist_scalar[upper.tri(dist_scalar, diag = T)]
range(values, na.rm = T)
allvals = rbind(allvals, data.frame(x=values, method="exp"))

# methods that don't involve log
dist_scalar = sim2diss(log.scores, method = "reverse")
values = dist_scalar[upper.tri(dist_scalar, diag = T)]
range(values, na.rm = T)
allvals = rbind(allvals, data.frame(x=values, method="reverse"))

dist_scalar = sim2diss(log.scores, method = "reciprocal")
values = dist_scalar[upper.tri(dist_scalar, diag = T)]
range(values, na.rm = T)
allvals = rbind(allvals, data.frame(x=values, method="reciprocal"))

dist_scalar = sim2diss(log.scores, method = "membership")
values = dist_scalar[upper.tri(dist_scalar, diag = T)]
range(values, na.rm = T)
allvals = rbind(allvals, data.frame(x=values, method="membership"))

# ranks will always give a uniform list from 1:n, which can't be plotted on the same range as the others and would be useless anyway because of the uniform distribution
# dist_scalar = sim2diss(log.scores, method = "ranks")
# values = dist_scalar[upper.tri(dist_scalar, diag = T)]
# range(values, na.rm = T)
# allvals = rbind(allvals, data.frame(x=values, method="ranks"))

dist_scalar = sim2diss(log.scores, method = 8)
df = data.frame(x=dist_scalar[upper.tri(dist_scalar, diag = T)], method="z=8")
allvals = rbind(allvals, data.frame(x=df$x, method="z=8"))
range(df$x, na.rm = T)


ggplot(allvals, aes(x=x)) + geom_histogram() + facet_wrap(~method)  + xlim(c(-7,7)) + ggtitle('Different sim2diss methods')           
```


```{r hclust-diagnostic, eval=FALSE}
bench=clusterbenchstats(dist_scalar, 2:5, clustermethod="hclustCBI", clustermethodpars=list(list(method="average")
                                                                                            ))

```

```{r mds}
dist.methods = list(
  cosine = proxy::dist(log.scores, method=distance.cosine),
  euclidean = dist(log.scores, method="euclidean"),
  maximum = dist(log.scores, method="maximum"),
#  manhattan = dist(log.scores, method="manhattan"), # most things are on widely different scales, so 
#  canberra = dist(log.scores, method="canberra"),   # different subsets have to be plotted at once
  binary = dist(log.scores, method="binary"),
  minkowski = dist(log.scores, method="minkowski"))



all.mds.df = data.frame()


for (method in names(dist.methods))
{
  dist.scores = dist.methods[[method]]
  mds.coord = cmdscale(dist.scores)
  mds.coord.df = data.frame(mds.coord,factorname=allfactors, method=method)
  mds.coord.df$kudron_cluster = "none"
  mds.coord.df %<>% mutate(kudron_cluster = ifelse(factorname %in% neuro.genelist, 
                                                   "neuro", kudron_cluster))
  mds.coord.df %<>% mutate(kudron_cluster = ifelse(factorname %in% muscle.genelist, 
                                                   "muscle", kudron_cluster))
  mds.coord.df %<>% mutate(kudron_cluster = ifelse(factorname %in% intestine.genelist, 
                                                   "intestine", kudron_cluster))
  mds.coord.df %<>% mutate(kudron_cluster = ifelse(factorname %in% germline.genelist, 
                                                   "germline", kudron_cluster))
  mds.coord.df %<>% mutate(kudron_cluster = ifelse(factorname %in% synMuvB.genelist, 
                                                   "synMuvB", kudron_cluster))
  mds.coord.df$kudron_cluster = factor(mds.coord.df$kudron_cluster)
  all.mds.df = rbind(all.mds.df, mds.coord.df)
}

ggplot(all.mds.df, aes(x=X1, y=X2, color=kudron_cluster)) + geom_point(alpha=ifelse(all.mds.df$kudron_cluster=="none", 0.1,1)) + facet_wrap(~method)
```


```{r hclustering}
hist(dist_scalar)
hc = hclust(as.dist(dist_scalar))
hc4 = cutree(hc,4)

mds.coord.df$hc4 = factor(hc4)

ggplot(mds.coord.df, aes(x=X1, y=X2,label=allfactors,  color=hc4)) + geom_point()

```



#mx5 = agnes(mx4, stand = TRUE)
#plot(mx5)
```

```{r heatmaps}
# Draw heatmaps
pheatmap(test)
pheatmap(test, kmeans_k = 2)
pheatmap(test, scale = "row", clustering_distance_rows = "correlation")
pheatmap(test, color = colorRampPalette(c("navy", "white", "firebrick3"))(50))
pheatmap(test, cluster_row = FALSE)
pheatmap(test, legend = FALSE)

# Show text within cells
pheatmap(test, display_numbers = TRUE)
pheatmap(test, display_numbers = TRUE, number_format = "%.1e")
pheatmap(test, display_numbers = matrix(ifelse(test > 5, "*", ""), nrow(test)))
pheatmap(test, cluster_row = FALSE, legend_breaks = -1:4, legend_labels = c("0",
"1e-4", "1e-3", "1e-2", "1e-1", "1"))

# Fix cell sizes and save to file with correct size
pheatmap(test, cellwidth = 15, cellheight = 12, main = "Example heatmap")
pheatmap(test, cellwidth = 15, cellheight = 12, fontsize = 8, filename = "test.pdf")

# Generate annotations for rows and columns
annotation_col = data.frame(
                    CellType = factor(rep(c("CT1", "CT2"), 5)), 
                    Time = 1:5
                )
rownames(annotation_col) = paste("Test", 1:10, sep = "")

annotation_row = data.frame(
                    GeneClass = factor(rep(c("Path1", "Path2", "Path3"), c(10, 4, 6)))
                )
rownames(annotation_row) = paste("Gene", 1:20, sep = "")

# Display row and color annotations
pheatmap(test, annotation_col = annotation_col)
pheatmap(test, annotation_col = annotation_col, annotation_legend = FALSE)
pheatmap(test, annotation_col = annotation_col, annotation_row = annotation_row)

# Change angle of text in the columns
pheatmap(test, annotation_col = annotation_col, annotation_row = annotation_row, angle_col = "45")
pheatmap(test, annotation_col = annotation_col, angle_col = "0")

# Specify colors
ann_colors = list(
    Time = c("white", "firebrick"),
    CellType = c(CT1 = "#1B9E77", CT2 = "#D95F02"),
    GeneClass = c(Path1 = "#7570B3", Path2 = "#E7298A", Path3 = "#66A61E")
)

pheatmap(test, annotation_col = annotation_col, annotation_colors = ann_colors, main = "Title")
pheatmap(test, annotation_col = annotation_col, annotation_row = annotation_row, 
         annotation_colors = ann_colors)
pheatmap(test, annotation_col = annotation_col, annotation_colors = ann_colors[2]) 

# Gaps in heatmaps
pheatmap(test, annotation_col = annotation_col, cluster_rows = FALSE, gaps_row = c(10, 14))
pheatmap(test, annotation_col = annotation_col, cluster_rows = FALSE, gaps_row = c(10, 14), 
         cutree_col = 2)

# Show custom strings as row/col names
labels_row = c("", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "Il10", "Il15", "Il1b")

pheatmap(test, annotation_col = annotation_col, labels_row = labels_row)

# Specifying clustering from distance matrix
drows = dist(test, method = "minkowski")
dcols = dist(t(test), method = "minkowski")
pheatmap(test, clustering_distance_rows = drows, clustering_distance_cols = dcols)

# Modify ordering of the clusters using clustering callback option
callback = function(hc, mat){
    sv = svd(t(mat))$v[,1]
    dend = reorder(as.dendrogram(hc), wts = sv)
    as.hclust(dend)
}

pheatmap(test, clustering_callback = callback)

## Not run: 
# Same using dendsort package
library(dendsort)

callback = function(hc, ...){dendsort(hc)}
pheatmap(test, clustering_callback = callback)

## End(Not run)
```
